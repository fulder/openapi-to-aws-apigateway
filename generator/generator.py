import argparse
import json
import logging
import os
import shutil

import yaml

CURRENT_FOLDER = os.path.dirname(os.path.realpath(__file__))

logger = logging.getLogger(__name__)


class Generator:

    def __init__(self, openapi_path: str, backend_url: str, proxy: bool, vpc_link_id: str):
        self.openapi_path = openapi_path
        self.backend_url = backend_url
        self.proxy = proxy
        self.vpc_link_id = vpc_link_id

        self.output_folder = os.path.abspath(os.path.join(CURRENT_FOLDER, "out"))
        self.output_path_sam = os.path.join(self.output_folder, "apigateway.yaml")
        self.stage_variables = {"backendUrl": self.backend_url}

        # Created by helper funcs during generate
        self.docs = None
        self.backend_type = None
        self.docs_type = None
        self.output_path_openapi = None
        self.cloudformation = None

    def generate(self):
        # Don't dump reference pointers
        yaml.SafeDumper.ignore_aliases = lambda *args: True

        self._create_empty_output_folder()
        self._load_file()
        self._docs_version()
        self._init_sam_template()

        self._determine_backend_type()

        self._extend_verbs()

        self._save_openapi()
        self._save_cloudformation()

    def _create_empty_output_folder(self):
        if os.path.isdir(self.output_folder):
            shutil.rmtree(self.output_folder)
        os.mkdir(self.output_folder)

    @property
    def is_lambda_integration(self):
        return self.backend_url.startswith("arn:")

    def _load_file(self):
        with open(self.openapi_path, "r") as f:
            if ".json" in self.openapi_path:
                self.docs = json.load(f)
            else:
                self.docs = yaml.safe_load(f)

    def _docs_version(self):
        if "swagger" in self.docs and self.docs["swagger"].startswith("2.0"):
            self.docs_type = "swagger"
            self.output_path_openapi = os.path.join(self.output_folder, "swagger.yaml")
        elif "openapi" in self.docs and self.docs["openapi"].startswith("3.0"):
            self.docs_type = "openapi"
            self.output_path_openapi = os.path.join(self.output_folder, "openapi.yaml")
        else:
            raise RuntimeError("Unsupported docs type. Supported: Swagger 2.0, OpenAPI 3.0")

    def _init_sam_template(self):
        self.cloudformation = {
            "AWSTemplateFormatVersion": "2010-09-09",
            "Transform": "AWS::Serverless-2016-10-31",
            "Description": "ApiGateway stack auto generated by openapi-aws-apigateway-generator",
            "Resources": {
                "Api": {
                    "Type": "AWS::Serverless::Api",
                    "Properties": {
                        "StageName": "default",
                        "DefinitionUri": self.output_path_openapi,
                        "Variables": self.stage_variables,
                    }
                }
            }
        }

    def _determine_backend_type(self):
        if self.is_lambda_integration:
            self.backend_type = "aws"
        else:
            self.backend_type = "http"

        if self.proxy:
            self.backend_type += "_proxy"
        logger.debug("Determined backend type as: [%s]", self.backend_type)

    def _extend_verbs(self):
        integration = self._init_integration()

        for p in self.docs["paths"]:
            for v in self.docs["paths"][p]:
                verb = self.docs["paths"][p][v]

                logger.debug("Adding integration to [%s %s]", v, p)
                self._create_integration(v, p, verb, integration)

    def _init_integration(self) -> dict:
        integration = {
            "requestParameters": {},
            "responses": {},
            "type": self.backend_type
        }
        if self.vpc_link_id:
            logger.debug("Adding connectionId: [%s] to all integrations", self.vpc_link_id)
            integration["connectionId"] = self.vpc_link_id
            integration["connectionType"] = "VPC_LINK"
        else:
            integration["connectionType"] = "INTERNET"
        return integration

    def _create_integration(self, method: str, path: str, verb: dict, integration: dict):
        if self.is_lambda_integration:
            integration["httpMethod"] = "POST"
        else:
            integration["httpMethod"] = method

        if self.is_lambda_integration:
            integration["uri"] = self.backend_url
        else:
            integration["uri"] = "{}{}".format(self.backend_url, path)

        responses = verb.get("responses")
        if responses:
            logger.debug("Adding responses for verb")

            amz_responses = {}
            for r in responses:
                amz_responses[r] = {
                    "statusCode": r
                }
            integration["responses"] = amz_responses

        verb["x-amazon-apigateway-integration"] = integration

    def _save_openapi(self):
        with open(self.output_path_openapi, "w") as f:
            yaml.safe_dump(self.docs, f, default_flow_style=False, sort_keys=False)
        logger.info("Saved OpenAPI template with amazon extensions to: [%s]", self.output_path_openapi)

    def _save_cloudformation(self):
        with open(self.output_path_sam, "w") as f:
            yaml.safe_dump(self.cloudformation, f, default_flow_style=False, sort_keys=False)
        logger.info("Saved SAM template file to: [%s]", self.output_path_sam)


def main():
    parser = argparse.ArgumentParser(description="Generate AWS ApiGateway CloudFormation from OpenAPI specification")
    # Required params
    parser.add_argument("--file", "-f", required=True, type=str, help="Path to the OpenAPI specification file")
    parser.add_argument("--backend_url", "-u", required=True, type=str,
                        help="Backend URL to forward the requests to (use ARN for lambda backend)")

    # Optional params
    parser.add_argument("--proxy", "-p", required=False, action="store_true", help="Proxy all requests to the backend")
    parser.add_argument("--vpc_link_id", "-v", required=False, help="If backend is an VPC link, provide the link ID")
    args = parser.parse_args()
    generator = Generator(args.file, args.backend_url, args.proxy, args.vpc_link_id)
    generator.generate()


if __name__ == "__main__":
    logger.addHandler(logging.StreamHandler())
    logger.setLevel("INFO")
    main()
